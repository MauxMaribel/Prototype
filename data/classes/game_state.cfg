{
	bases: ['game_state_base'],

	constructor: "[
		read_level()
	]",

	properties: {

		units: { type: "[class unit]", default: [] },

		//fill this in with a calculation later to
		//give 0 if the player has won and 1 if the player has lost.
		//It should be null if there is no winner yet.
		winner_index: "int|null :: null",

		//name of the level we are in.
		level: { type: "string" },

		map_topleft: { type: "[int,int]", default: [0,0] },
		map_dim: { type: "[int,int]", default: [1,1] },
		map_tiles: { type: "{Loc->string}", default: {} },

		get_tile: "def(Loc loc) ->string
		map_tiles[loc] or ''
		",

		tile_dim_px: "int :: 64",

		read_level: "def() ->commands
		[
			set(map_dim, [max_x - min_x, max_y - min_y]),
			set(map_topleft, [min_x, min_y]),
			set(map_tiles, all_locs),
		]
		where min_x = int<- min(map(all_locs, key.x))
		where min_y = int<- min(map(all_locs, key.y))
		where max_x = int<- max(map(all_locs, key.x))
		where max_y = int<- max(map(all_locs, key.y))
		where all_locs = fold(loc_maps, a.locs+b.locs, {})
		where loc_maps = map(tile_maps,

		{
			xpos: xpos,
			ypos: ypos,
			locs: tile_loc_map,
		}
		
		where tile_loc_map = filter(fold(tile_contents, a+b, {}), value != '')
		where tile_contents = fold(map(tile_lines,
			map(split(value, ','),
			{
				([xco, yco]): value,
			}
			 where xco = xpos + index
			)
			where yco = ypos + index
		), a+b, [])
		where tile_lines = split(tiles, '\n')
		where xpos = (int<- m['x'])/tile_dim_px
		where ypos = (int<- m['y'])/tile_dim_px
		where tiles = string<- m['tiles']
		where m = value
		)
		where tile_maps = sort(tile_maps_unsorted, zorders[a['zorder']] < zorders[b['zorder']])
		where tile_maps_unsorted = [map]<- level_doc['tile_map']
		where level_doc = map<- get_document(sprintf('data/level/%s', level))
		where zorders = {string->int}<- get_document('data/zorder.cfg')",
	},
}
