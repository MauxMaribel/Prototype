{
	id: "game_controller",
	is_strict: true,
	is_human: true,
	always_active: true,
	hidden_in_game: true,

	prototype: ["game_controller_base"],

	properties: {
		myplayer: { type: "int", default: 0 },
		myturn: "state.current_player_index = myplayer",

		fire_controllers: { type: "{Loc -> obj particle_controller}", default: {} },

		characters: { type: "[obj character]", default: [] },

		_end_turn_button: { type: "null|obj button_controller" },

		_show_end_turn_button: "def() ->commands

		if(should_show = false and _end_turn_button, [
			remove_object(_end_turn_button),
			set(_end_turn_button, null),
		],
		should_show and _end_turn_button = null, [
			spawn('button_controller', {
				text: 'End Turn',
				button_width: lib.gui.py(120),
				button_height: lib.gui.py(30),
				_font_size: lib.gui.py(20),
				x2: level.camera_position[2] - 20,
				y2: level.camera_position[3] - 20,
				zorder: 1000,

				on_click: me.end_turn,
			}, [
				set(_end_turn_button, child),
			])
		])

		where should_show = (myturn and state.active_unit = null)
		",

		end_turn: "def() ->commands
		[
			clear_selected_character(),
			send({
				type: 'end_turn',
			}),
		]
		",

		present_animation_blocking: "def(class animation anim) ->commands
		if(anim is class animation.move_unit,
			_animate_move(anim),
		   anim is class animation.attack_unit,
			_animate_attack(anim),
		   anim is class animation.remove_terrain,
			_animate_remove_terrain(anim),
		   anim is class animation.add_terrain,
			_animate_add_terrain(anim),
		   anim is class animation.unit_death,
		    _animate_unit_death(anim)
		)
		",		

		_animate_move: "def(class animation.move_unit anim) ->commands

		if(u != null,
			map(anim.path[1:],
				u.walk_to_tile_blocking(value)
			)
		)
		
		where u = find(characters, value.unit_info._uuid = anim.unit._uuid)
		",

		_animate_attack: "def(class animation.attack_unit anim) ->commands
		if(target_unit,
		[
			target_unit.show_life_bar();
			let starting_x = u.mid_x;
			let starting_y = u.mid_y;
			animate(u, {
				mid_x: int(mix(u.mid_x, target_unit.mid_x, 0.5)),
				mid_y: int(mix(u.mid_y, target_unit.mid_y, 0.5)),
			}, {
				duration: 6,
				sleep: true,
			});
			target_unit.animate_damage(anim.damage);
			animate(u, {
				mid_x: starting_x,
				mid_y: starting_y,
			}, {
				duration: 20,
				sleep: true,
			})
		],

		[
			let starting_x = u.mid_x;
			let starting_y = u.mid_y;
			animate(u, {
				mid_x: int(mix(u.mid_x, anim.target.x*TILE_DIM + TILE_DIM/2, 0.5)),
				mid_y: int(mix(u.mid_y, anim.target.y*TILE_DIM + TILE_DIM/2, 0.5)),
			}, {
				duration: 6,
				sleep: true,
			});
			set_tiles(-100, [anim.target.x*TILE_DIM, anim.target.y*TILE_DIM, (anim.target.x+1)*TILE_DIM-1, (anim.target.y+1)*TILE_DIM-1], '');
			animate(u, {
				mid_x: starting_x,
				mid_y: starting_y,
			}, {
				duration: 12,
				sleep: true,
			})
		]

		)
		where u = find_or_die(characters, value.unit_info._uuid = anim.unit._uuid)
		where target_unit = find(characters, value.unit_info.loc = anim.target)
		",

		_animate_unit_death: "def(class animation.unit_death anim) ->commands
		if(u,
			animate(u, {
				alpha: 0,
			}, {
				duration: 15,
				sleep: true,
			})
		)
		where u = find_or_die(characters, value.unit_info._uuid = anim.unit._uuid)
		",

		_animate_remove_terrain: "def(class animation.remove_terrain anim) ->commands
			set_tiles(anim.zorder, [anim.target.x*TILE_DIM, anim.target.y*TILE_DIM, (anim.target.x+1)*TILE_DIM-1, (anim.target.y+1)*TILE_DIM-1], '')

		",

		_animate_add_terrain: "def(class animation.add_terrain anim) ->commands
			set_tiles(anim.zorder, [anim.target.x*TILE_DIM, anim.target.y*TILE_DIM, (anim.target.x+1)*TILE_DIM-1, (anim.target.y+1)*TILE_DIM-1], anim.terrain)
		",

		present_game_state: "def() ->commands
		[
			_present_fire(),

			_show_end_turn_button(),

			if(myturn = false, clear_selected_character()),

			[remove_object(c) | c <- characters, find(state.units, value._uuid = c.unit_info._uuid) = null];
			set(characters, [c | c <- characters, find(state.units, value._uuid = c.unit_info._uuid) != null]);

			map(characters, value.unit_info_updated());

			[spawn(c.id, {
				_unit_info: c,
				game_controller: me,
			}, [
				add(characters, [child]),
				child.unit_info_updated(),
			] asserting child is obj character)
			| c <- state.units, find(characters, value.unit_info._uuid = c._uuid) = null];

			if(myturn and state.active_unit != null,
				if(u != null,
				[
					clear_selected_character(),
					set_active_character(u),
				],
				debug('could not find active unit')
				)
			where u = find(characters, value.unit_info._uuid = state.active_unit._uuid)
			),
		]
		",

		_present_fire: "def() ->commands
		[
			map(fire_controllers, if(key not in state.fires, [
				animate(value, {
					emission_rate: 0.0,
				}, {
					duration: 30,
				}),

				schedule(60, remove_object(value))
			]));

			set(fire_controllers, filter(fire_controllers, key in state.fires));

			map(filter(state.fires, key not in fire_controllers), ;
				spawn('particle_controller', {
					_type: 'fire',
					xy: [key.x*TILE_DIM + TILE_DIM/2, key.y*TILE_DIM + TILE_DIM/2 + 14],
					zorder: 100 + key.y+1,
				}, [
					set(fire_controllers[key], child),
				])
			)
		]",

		rest_active_character: "def() ->commands
		[
			clear_active_character(),
			send({
				type: 'rest_unit',
				unit_id: _active_character.unit_info._uuid,
			}),
		]
		asserting _active_character != null
		",


		_active_character: { type: "null|obj character" },
		_active_character_buttons: { type: "[obj icon_button]", default: [] },

		set_active_character: "def(obj character c) ->commands
		[
			clear_active_character(),
			set(_active_character, c),

			spawn('icon_button', {
				mid_x: c.mid_x,
				mid_y: c.mid_y - lib.gui.py(40),
				icon: 'lob-arrow.svg',
				tooltip: 'Rest',
				handle_click: rest_active_character,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [0.0,1.0,0.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

			spawn('icon_button', {
				mid_x: c.mid_x - lib.gui.py(40),
				mid_y: c.mid_y,
				icon: 'sword-hilt.svg',
				tooltip: 'Attack',
				handle_click: start_attack,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [1.0,0.0,0.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

			spawn('icon_button', {
				mid_x: c.mid_x,
				mid_y: c.mid_y + lib.gui.py(40),
				icon: 'magic-swirl.svg',
				tooltip: if(c.unit_info.spells, 'Magic', 'No Magical Spells'),
				disabled: c.unit_info.spells = [],
				handle_click: show_spells,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [1.0,0.0,1.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

			spawn('icon_button', {
				mid_x: c.mid_x + lib.gui.py(40),
				mid_y: c.mid_y,
				icon: 'magic-potion.svg',
				tooltip: 'Items',
				handle_click: rest_active_character,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [0.0,0.0,1.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

		]
		",

		cancel_active_option: "def() ->commands [
			clear_attack_preview(),

			map(_active_character_buttons, remove_object(value)),
			set(_active_character_buttons, []),

			if(_active_character, set_active_character(_active_character)),
		]",

		show_spells: "def() ->commands if(_active_character, [
			map(_active_character_buttons, remove_object(value)),
			set(_active_character_buttons, []),

			spawn('icon_button', {
				mid_x: c.mid_x,
				mid_y: c.mid_y + lib.gui.py(40),
				icon: 'cancel.svg',
				tooltip: 'Back',
				handle_click: cancel_active_option,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [1.0,1.0,1.0],
				icon_color: [1.0,0.0,0.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

			map(_active_character.unit_info.spells,
				spawn('icon_button', {
					mid_xy: [
					  [c.mid_x - lib.gui.py(40), c.mid_y],
					  [c.mid_x, c.mid_y - lib.gui.py(40)],
					  [c.mid_x + lib.gui.py(40), c.mid_y],
					][index],
					icon: spell.icon,
					tooltip: spell.name + if(value.cooldown, sprintf('\nCooldown: %d', value.cooldown), ''),
					handle_click: bind(me.start_cast, spell),
					zorder: c.zorder + 1000,
					texture_size: lib.gui.py(48),
					bg_color: [1.0,1.0,1.0],
					icon_color: spell.icon_color,
					disabled: if(value.cooldown, true, false),
				}, [
					add(_active_character_buttons, [child]),
				])
				where spell = lib.game.get_spell(value.spell)
			)
		]
		where c = _active_character 
		)",

		start_cast: "def(class spell spell) ->commands if(_active_character, [
			map(_active_character_buttons, remove_object(value)),
			set(_active_character_buttons, []),

			if(targets != null, _show_attack_preview(targets, spell))
			where targets = spell.get_possible_targets(state, _active_character.unit_info),

			spawn('icon_button', {
				mid_x: c.mid_x - lib.gui.py(40),
				mid_y: c.mid_y,
				icon: 'cancel.svg',
				tooltip: 'Back',
				handle_click: (def() ->commands clear_attack_preview(); show_spells()),
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [1.0,1.0,1.0],
				icon_color: [1.0,0.0,0.0],
			}, [
				add(_active_character_buttons, [child]),
			]) where c = _active_character,
		])",


		start_attack: "def() ->commands if(_active_character, [
			map(_active_character_buttons, remove_object(value)),
			set(_active_character_buttons, []),
			show_attack_preview(),

			spawn('icon_button', {
				mid_x: c.mid_x - lib.gui.py(40),
				mid_y: c.mid_y,
				icon: 'cancel.svg',
				tooltip: 'Back',
				handle_click: cancel_active_option,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [1.0,1.0,1.0],
				icon_color: [1.0,0.0,0.0],
			}, [
				add(_active_character_buttons, [child]),
			]) where c = _active_character,

		])",

		clear_active_character: "def() ->commands [
			set(_active_character, null),
			map(_active_character_buttons, remove_object(value)),
			set(_active_character_buttons, []),
		]",

		_selected_character: { type: "null|obj character" },
		_tile_highlights: { type: "[obj tile_highlight]", default: [] },
		_attack_preview: { type: "[obj tile_highlight]", default: [] },
		_attack_preview_loc: { type: "Loc", default: [0,0] },

		clear_selected_character: "def() ->commands
		[
			set(_selected_character, null),
			map(_tile_highlights, remove_object(value)),
			set(_tile_highlights, []),

			clear_attack_preview(),
		]
		",

		clear_attack_preview: "def() ->commands
		[
			map(_attack_preview, remove_object(value)),
			set(_attack_preview, []),
		]
		",

		highlight_tiles: "def([Loc] locs) ->commands
			map(locs,
				spawn('tile_highlight', {
					zorder: 100,
					x: value.x*TILE_DIM,
					y: value.y*TILE_DIM,
					loc: value,
					handle_click: move_tile_clicked,
					handle_mouseover: move_tile_mouseover,
					handle_mouseoff: move_tile_mouseoff,
				}, [
					add(_tile_highlights, [child]),
				])
			)
		",

		move_tile_clicked: "def(Loc loc) ->commands
		if(_selected_character != null,
		[
			clear_selected_character(),
			send({
				type: 'move_unit',
				unit_id: _selected_character.unit_info._uuid,
				dst: loc,
			}),
		]
		)
		",

		move_tile_mouseover: "def(Loc loc) ->commands
		if(_selected_character != null,
		[
			set(_attack_preview_loc, loc),

		//	_show_attack_preview(targets),

		] where targets = state.get_attack_locs(_selected_character.unit_info, loc))
		",

		show_attack_preview: "def() ->commands
		if(_active_character != null,
		[
			_show_attack_preview(targets),

		] where targets = state.get_attack_locs(_active_character.unit_info, _active_character.unit_info.loc)
		)
		",

		_show_attack_preview: "def([Loc] targets, null|class spell spell=null) ->commands
		[
			clear_attack_preview(),

			map(targets,
				spawn('tile_highlight', {
					zorder: 200,
					x: value.x*TILE_DIM,
					y: value.y*TILE_DIM,
					loc: value,
					green: 0,
					blue: 0,
					alpha: 128,
					oscillate: false,
					handle_click: if(spell, bind(spell_cast, spell), attack_tile_clicked),
				}, [
					add(_attack_preview, [child]),
				])
			)
		]
		",

		attack_tile_clicked: "def(Loc loc) ->commands
		if(_active_character != null,
		[
			clear_active_character(),
			clear_attack_preview(),
			send({
				type: 'attack_unit',
				unit_id: _active_character.unit_info._uuid,
				target_loc: loc,
			})
		]
		)
		",

		spell_cast: "def(class spell spell, Loc loc) ->commands
		if(_active_character != null,
		[
			clear_active_character(),
			clear_attack_preview(),
			send({
				type: 'cast_spell',
				unit_id: _active_character.unit_info._uuid,
				spell_id: spell.id,
				target_loc: loc,
			})
		]
		)
		",
		
		move_tile_mouseoff: "def(Loc loc) ->commands
		if(_attack_preview_loc = loc,
			clear_attack_preview()
		)
		",

		character_selectable: "def(obj character c) ->bool myturn and c.unit_info.side = myplayer and c.unit_info.has_moved = false and _active_character = null",

		character_clicked: "def(obj character c) ->commands if(character_selectable(c), [
			clear_selected_character(),
			set(_selected_character, c),

			highlight_tiles(lib.pathfind.possible_moves(state, c.unit_info)),

		])
		",

		character_right_clicked: "def(obj character c) ->commands
			null
		",

		tile_mid_x: "def(Loc loc) ->int loc.x*TILE_DIM + TILE_DIM/2",
		tile_mid_y: "def(Loc loc) ->int loc.y*TILE_DIM + TILE_DIM/2",

		screen_focus_loc: "def(Loc loc) ->commands [
			set(screen_x, tile_mid_x(loc) - SCREEN_WIDTH/2),
			set(screen_y, tile_mid_y(loc) - SCREEN_HEIGHT/2),
		]",

		screen_x: { type: "int", default: 0, set: "set(_data, clamp(value, level.dimensions.x, level.dimensions[2] - SCREEN_WIDTH))" },
		screen_y: { type: "int", default: 0, set: "set(_data, clamp(value, level.dimensions.y, level.dimensions[3] - SCREEN_HEIGHT))" },
	},

	events: {
		create: "
		set(level.lock_screen, [screen_x + SCREEN_WIDTH/2, screen_y + SCREEN_HEIGHT/2]);
		
		let characters = filter(level.chars, value is obj character);
		map(characters, remove_object(value));
		schedule(1, ;
		send({
			type: 'setup_characters',
			characters: [

			if(construct('unit', info), info, {})
			
			where info = lib.game.generate_unit(c.type) + {
				id: c.type,
				loc: c.calculate_loc,
				side: if(c is obj character_mage, 0, 1),
			} | c <- characters],
		})
		)
		",

		process: "
		[
			complete_rebuild_tiles(),

			set(level.camera_position, [screen_x, screen_y]),
			set(level.lock_screen, [screen_x + SCREEN_WIDTH/2, screen_y + SCREEN_HEIGHT/2]),

			if(level.player.ctrl_down, add(screen_y, 10)),
			if(level.player.ctrl_up, add(screen_y, -10)),
			if(level.player.ctrl_left, add(screen_x, -10)),
			if(level.player.ctrl_right, add(screen_x, 10)),
		]
		",
	},
}
