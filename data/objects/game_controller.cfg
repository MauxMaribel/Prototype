{
	id: "game_controller",
	is_strict: true,
	is_human: true,
	always_active: true,
	hidden_in_game: true,

	prototype: ["game_controller_base"],

	properties: {
		myplayer: { type: "int", default: 0 },
		myturn: "state.current_player_index = myplayer",

		characters: { type: "[obj character]", default: [] },

		_end_turn_button: { type: "null|obj button_controller" },

		_show_end_turn_button: "def() ->commands

		if(should_show = false and _end_turn_button, [
			remove_object(_end_turn_button),
			set(_end_turn_button, null),
		],
		should_show and _end_turn_button = null, [
			spawn('button_controller', {
				text: 'End Turn',
				button_width: lib.gui.py(120),
				button_height: lib.gui.py(30),
				_font_size: lib.gui.py(20),
				x2: level.camera_position[2] - 20,
				y2: level.camera_position[3] - 20,
				zorder: 1000,

				on_click: me.end_turn,
			}, [
				set(_end_turn_button, child),
			])
		])

		where should_show = (myturn and state.active_unit = null)
		",

		end_turn: "def() ->commands
		[
			clear_selected_character(),
			send({
				type: 'end_turn',
			}),
		]
		",

		present_animation_blocking: "def(class animation anim) ->commands
		if(anim is class animation.move_unit,
			_animate_move(anim)
		)
		",		

		_animate_move: "def(class animation.move_unit anim) ->commands

		if(u != null,
			map(anim.path[1:],
				u.walk_to_tile_blocking(value)
			)
		)
		
		where u = find(characters, value.unit_info._uuid = anim.unit._uuid)
		",

		present_game_state: "def() ->commands
		[
			_show_end_turn_button(),

			if(myturn = false, clear_selected_character()),

			[remove_object(c) | c <- characters, find(state.units, value._uuid = c.unit_info._uuid) = null];
			set(characters, [c | c <- characters, find(state.units, value._uuid = c.unit_info._uuid) != null]);

			map(characters, value.unit_info_updated());

			[spawn(c.id, {
				_unit_info: c,
				game_controller: me,
			}, [
				add(characters, [child]),
				child.unit_info_updated(),
			] asserting child is obj character)
			| c <- state.units, find(characters, value.unit_info._uuid = c._uuid) = null];

			if(myturn and state.active_unit != null,
				if(u != null,
				[
					clear_selected_character(),
					set_active_character(u),
				],
				debug('could not find active unit')
				)
			where u = find(characters, value.unit_info._uuid = state.active_unit._uuid)
			),
		]
		",

		rest_active_character: "def() ->commands
		[
			clear_active_character(),
			send({
				type: 'rest_unit',
				unit_id: _active_character.unit_info._uuid,
			}),
		]
		asserting _active_character != null
		",


		_active_character: { type: "null|obj character" },
		_active_character_buttons: { type: "[obj icon_button]", default: [] },

		set_active_character: "def(obj character c) ->commands
		[
			clear_active_character(),
			set(_active_character, c),

			spawn('icon_button', {
				mid_x: c.mid_x,
				mid_y: c.mid_y - lib.gui.py(40),
				icon: 'lob-arrow.svg',
				tooltip: 'Rest',
				handle_click: rest_active_character,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [0.0,1.0,0.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

			spawn('icon_button', {
				mid_x: c.mid_x - lib.gui.py(40),
				mid_y: c.mid_y,
				icon: 'sword-hilt.svg',
				tooltip: 'Attack',
				handle_click: rest_active_character,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [1.0,0.0,0.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

			spawn('icon_button', {
				mid_x: c.mid_x,
				mid_y: c.mid_y + lib.gui.py(40),
				icon: 'magic-swirl.svg',
				tooltip: 'Magic',
				handle_click: rest_active_character,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [1.0,0.0,1.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

			spawn('icon_button', {
				mid_x: c.mid_x + lib.gui.py(40),
				mid_y: c.mid_y,
				icon: 'magic-potion.svg',
				tooltip: 'Items',
				handle_click: rest_active_character,
				zorder: c.zorder + 1000,
				texture_size: lib.gui.py(48),
				bg_color: [0.0,0.0,1.0],
			}, [
				add(_active_character_buttons, [child]),
			]),

		]
		",

		clear_active_character: "def() ->commands [
			set(_active_character, null),
			map(_active_character_buttons, remove_object(value)),
			set(_active_character_buttons, []),
		]",

		_selected_character: { type: "null|obj character" },
		_tile_highlights: { type: "[obj tile_highlight]", default: [] },

		clear_selected_character: "def() ->commands
		[
			set(_selected_character, null),
			map(_tile_highlights, remove_object(value)),
			set(_tile_highlights, []),
		]
		",

		highlight_tiles: "def([Loc] locs) ->commands
			map(locs,
				spawn('tile_highlight', {
					zorder: 100,
					x: value.x*TILE_DIM,
					y: value.y*TILE_DIM,
					loc: value,
					handle_click: tile_clicked,
				}, [
					add(_tile_highlights, [child]),
				])
			)
		",

		tile_clicked: "def(Loc loc) ->commands
		if(_selected_character != null,
		[
			clear_selected_character(),
			send({
				type: 'move_unit',
				unit_id: _selected_character.unit_info._uuid,
				dst: loc,
			}),
		]
		)
		",

		character_selectable: "def(obj character c) ->bool myturn and c.unit_info.side = myplayer and c.unit_info.has_moved = false and _active_character = null",

		character_clicked: "def(obj character c) ->commands if(character_selectable(c), [
			clear_selected_character(),
			set(_selected_character, c),

			highlight_tiles(lib.pathfind.possible_moves(state, c.unit_info)),

		])
		",

		character_right_clicked: "def(obj character c) ->commands
			null
		",

		tile_mid_x: "def(Loc loc) ->int loc.x*TILE_DIM + TILE_DIM/2",
		tile_mid_y: "def(Loc loc) ->int loc.y*TILE_DIM + TILE_DIM/2",

		screen_focus_loc: "def(Loc loc) ->commands [
			set(screen_x, tile_mid_x(loc) - SCREEN_WIDTH/2),
			set(screen_y, tile_mid_y(loc) - SCREEN_HEIGHT/2),
		]",

		screen_x: { type: "int", default: 0, set: "set(_data, clamp(value, level.dimensions.x, level.dimensions[2] - SCREEN_WIDTH))" },
		screen_y: { type: "int", default: 0, set: "set(_data, clamp(value, level.dimensions.y, level.dimensions[3] - SCREEN_HEIGHT))" },
	},

	events: {
		create: "
		set(level.lock_screen, [screen_x + SCREEN_WIDTH/2, screen_y + SCREEN_HEIGHT/2]);
		
		let characters = filter(level.chars, value is obj character);
		map(characters, remove_object(value));
		schedule(1, ;
		send({
			type: 'setup_characters',
			characters: [

			if(construct('unit', info), info, {})
			
			where info = lib.game.generate_unit(c.type) + {
				id: c.type,
				loc: c.calculate_loc,
				side: if(c is obj character_mage, 0, 1),
			} | c <- characters],
		})
		)
		",

		process: "
		[
			set(level.camera_position, [screen_x, screen_y]),
			set(level.lock_screen, [screen_x + SCREEN_WIDTH/2, screen_y + SCREEN_HEIGHT/2]),

			if(level.player.ctrl_down, add(screen_y, 10)),
			if(level.player.ctrl_up, add(screen_y, -10)),
			if(level.player.ctrl_left, add(screen_x, -10)),
			if(level.player.ctrl_right, add(screen_x, 10)),
		]
		",
	},
}
