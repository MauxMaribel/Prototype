{
	id: "title_controller",
	is_strict: true,
	hidden_in_game: true,

	prototype: ["title_controller_base"],

	properties: {

		// Function which presents the title screen's main UI.
		// It should construct all the UI elements the title screen
		// has to offer.
		_present_ui: "def() ->commands
			//make a button which when pressed enters the game
			spawn('button_controller', {
				text: 'Play!',
				mid_x: level.dimensions[2]/2,
				mid_y: level.dimensions[3]/2,
				_font_size: lib.gui.py(16),
				button_width: lib.gui.py(160),
				button_height: lib.gui.py(22),
				on_click: me.play_game,
			});

			//make a combo controller to let someone select the level to play
			spawn('combo_controller', {
				mid_x: level.dimensions[2]/2,
				mid_y: level.dimensions[3]/2 + lib.gui.py(40),
				_font_size: lib.gui.py(16),
				selected_index: 0,
				_width: lib.gui.py(160),
				_height: lib.gui.py(22),
				items: available_maps,
				on_change: def(int n) ->commands set(me.map_num, n),
			})
		",


		available_maps: "[string] ::
		map(
			filter(get_files_in_dir('data/level'), regex_match(value, 'map-.*\\.cfg')),

			regex_replace(regex_replace(value, '^map-', ''), '.cfg$', '')
		)
		",

		//called when someone clicks the Play button. Take them to the
		//level that is chosen.
		play_game: "def() ->commands
		execute(me, [

			//This is the message we use to setup the game.
			//This message gets handled by the server in
			//class tbs_game's create() function to construct
			//the actual game state. Any custom arguments to the
			//game / state / etc can be included here.
			let msg = {
				type: 'create_game',
				level: level_name,
				users: [{
					//maybe one day we will give the player a name when
					//setting up a game but for now they are just 'Player'.
					user: 'Player',
					session_id: 1,
				}, {
					user: 'CPU',
					bot_type: 'basic',
					bot: true,
					session_id: 2,
				}],
			};

			//Create a machine-local server and send it the request
			let client = tbs_internal_client();
			let request = tbs_blocking_request(client, msg);

			//We send the request to start the game and also start
			//doing a graphical transition effect at the same time.
			//These calls will block until both are complete.
			[
				request.block(),

				//TODO: add a cool transition effect when going into a game.
				//transition_effect_blocking('zoom_in'),
			];

			if((not request.response is map) or (map<-request.response).type != 'game_created', [
				//TODO: Creating a local game should rarely fail
				//but if it does we should have better error handling here.
				debug(['ERROR CREATING GAME', request.response]),
				cancel(),
			]);




			teleport(level_name, '', '', object_playable('game_controller', 0, 0, 1, {
				_mm_client_state: _mm_client_state,
				session_id: 1,

				//What to do when the game is over, for now just
				//teleport back to the titlescreen.
				return_from_game: def(bool result, null|class game_state game) ->commands
					teleport('titlescreen.cfg')
				
			})),
		
		])

		where level_name = sprintf('map-%s.cfg', available_maps[map_num])
		",

		map_num: { type: "int", default: 0 },

	},

	events: {
	},
}
