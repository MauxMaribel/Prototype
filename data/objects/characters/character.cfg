{
	id: "character",
	is_strict: true,
	always_active: true,

	editor_info: {
		category: "character",

	},

	properties: {
		game_controller: { type: "null|obj game_controller" },

		has_moved: { type: "bool", default: false, change: "animate(me, { saturation: if(has_moved, 0.0, 1.0), lum: if(has_moved, 0.7, 1.0) }, { duration: 10 })" },

		saturation: { type: "decimal", default: 1.0 },
		hue: { type: "decimal", default: 0.0 },
		lum: { type: "decimal", default: 1.0 },

		flash_hit: { type: "int", default: 0 },

		do_flash_hit: "def() ->commands
		[
			add(flash_hit, 1),
			schedule(2, add(flash_hit, -1)),
		]
		",

		_unit_info: { type: "null|class unit" },
		unit_info: "class unit<- _unit_info",

		unit_info_updated: "def() ->commands [
			set(mid_x, unit_info.loc.x*tile_dim + tile_dim/2 + position_offset.x),
			set(mid_y, unit_info.loc.y*tile_dim + tile_dim/2 + position_offset.y),
			set(_anim_loc, null),
			set(zorder, 100 + unit_info.loc.y),
			set(has_moved, unit_info.has_moved and (game_controller = null or (game_controller.state.active_unit = null or game_controller.state.active_unit._uuid != unit_info._uuid))),
			set(hue, unit_info.hue_shift),
		]",

		//how far to offset this character from the center
		//of the tile. Use this to adjust their position
		//in a tile.
		position_offset: "[int,int] :: [0,0]",

		calculate_loc: "[int,int] ::
		[
			(mid_x - tile_dim/2 - position_offset.x)/tile_dim,
			(mid_y - tile_dim/2 - position_offset.y)/tile_dim,
		]
		",

		walk_to_tile_blocking: "def(Loc dst) ->commands

		animate(me, {
			mid_x: dst.x*TILE_DIM + TILE_DIM/2 + position_offset.x,
			mid_y: dst.y*TILE_DIM + TILE_DIM/2 + position_offset.y,
		}, {
			easing: lib.math.linear,
			duration: 12,
			sleep: true,
			name: 'walk',
			replace_existing: false,

			on_begin: ; [
				set(facing, if(dst.x < loc.x, -1, 1)),
				if(desired_anim != animation, set(animation, desired_anim)),
				set(zorder, 100 + dst.y),
			],

			on_complete: ; [
				set(_anim_loc, dst),
			],
		})

		where desired_anim = if(walk_anim in available_animations, walk_anim, stand_anim in available_animations, stand_anim, animation)
		where stand_anim = sprintf('stand_%s', dir)
		where walk_anim = sprintf('walk_%s', dir)
		where dir = if(dst.y < loc.y, 'up', dst.y > loc.y, 'down', 'right')
		",

		_anim_loc: { type: "null|Loc" },

		loc: "Loc :: _anim_loc or unit_info.loc",

		tile_dim: "int :: 64",

	},

	events: {
		click: "if(game_controller,
			if(button = 1, game_controller.character_clicked(me),
			   button = 3, game_controller.character_right_clicked(me)),
		) where button = int<- arg.mouse_button",

		mouse_enter: "
		if(game_controller != null and game_controller.character_selectable(me),
			animate(me, {
				lum: 1.25,
			}, {
				duration: 10,
			})
		)
		",

		mouse_leave: "
		if(game_controller != null and (game_controller.character_selectable(me) or lum > 1.0),
			animate(me, {
				lum: 1.0,
			}, {
				duration: 10,
			})
		)
		",

		process: "
		if(animated_movements = [] and strstr(animation, 'walk'),
			set(animation, 'stand' + animation[4:])
		)
		",
	},

		shader: {
		name: "creature_render",

		vertex: "
        uniform mat4 u_anura_mvp_matrix;
        attribute vec4 a_anura_vertex;
        attribute vec2 a_anura_texcoord;
        varying vec2 v_texcoord;
        void main()
        {
            v_texcoord = a_anura_texcoord;
            gl_Position = u_anura_mvp_matrix * a_anura_vertex;
        }
		",

		fragment: "
        uniform sampler2D u_anura_tex_map;
		varying vec2 v_texcoord;
		uniform vec4 u_anura_sprite_area;
		uniform float u_property_saturation;
		uniform float u_property_hue;
		uniform float u_property_lum;
		uniform float u_property_alpha;
		uniform int u_property_flash_hit;
		vec3 rgb_to_hsv(vec3 c)
		{
			vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
			vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
			vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
			float d = q.x - min(q.w, q.y);
			float e = 1.0e-10;
			return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
		}
		vec3 hsv_to_rgb(vec3 c)
		{
			vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
			vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
			return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
		}
        void main()
        {
			gl_FragColor = texture2D(u_anura_tex_map, v_texcoord);
			vec3 hsv = rgb_to_hsv(gl_FragColor.rgb);
            hsv[0] += u_property_hue;
            hsv[1] *= u_property_saturation;
            hsv[2] *= u_property_lum;
			gl_FragColor.rgb = hsv_to_rgb(hsv);

			if(u_property_flash_hit > 0) {
				gl_FragColor.rgb = vec3(1,1,1);
			}

			gl_FragColor.a *= u_property_alpha/255.0;
		}
		",
	},
}
